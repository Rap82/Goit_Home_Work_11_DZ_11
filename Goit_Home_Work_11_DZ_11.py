# ============================== Модуль 11 / Modul 11 =============================================

# +++++++++++++++++++++++++++++  'Магічні' методи  ++++++++++++++++++++++++++++++++++++++

#                     1.'Магічні' методи
#                     2. Метод init
#                     3. Методи str та repr
#                     4. Методи getitem та setitem
#                     5. Функтори, метод call
#                     6. Створення власних менеджерів контексту
#                     7. Створення об'єкта ітератора/генератора
#                     8. Інкапсуляція у Python (property, setter).
#                     9. Перевизначення математичних операторів
#                     10. Перевизначення операцій порівняння


# ================================ Звдання 1 / Task 1 ======================================

# ================================  Метод init  ==========================

# Найчастіше використовуваний магічний метод — це метод __init__. Цей метод відповідає за ініціалізацію об'єкта. 
# Коли ви створюєте об'єкт класу, спочатку створюється порожній об'єкт, який містить лише обов'язкові службові атрибути. 
# Після цього (об'єкт вже створено) автоматично викликається метод __init__, який ви можете модифікувати під ваші потреби.

# class Human:
#     def __init__(self, name, age=0):
#         self.name = name
#         self.age = age

#     def say_hello(self):
#         return f'Hello! I am {self.name}'


# bill = Human('Bill')
# print(bill.say_hello())  # Hello! I am Bill
# print(bill.age)  # 0

# jill = Human('Jill', 20)
# print(jill.say_hello())  # Hello! I am Jill
# print(jill.age)  # 20
# В цьому прикладі ми створили клас Human, у якому визначили метод __init__. 
# У цьому методі ми додаємо об'єктам цього класу поля name та age. Зверніть увагу, 
# що метод __init__ може приймати аргументи позиційні і/або іменні, як будь-який інший метод. 
# Коли ми створюємо об'єкт класу Human, ми повинні класу передати обов'язково хоч один аргумент, 
# скільки метод __init__ повинен приймати обов'язково name.

# __init__ не обов'язково приймає аргументи та містить лише створення полів. 
# Цей метод можна використовувати для реалізації будь-яких дій, які вам потрібні на етапі, 
# коли об'єкт вже створено та його треба ініціалізувати.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Point, який відповідатиме за відображення геометричної точки на площині.

# Реалізуйте через конструктор __init__ ініціалізацію двох атрибутів: координати x та координати y.

# Приклад:

# point = Point(5, 10)

# print(point.x)  # 5
# print(point.y)  # 10

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Point: # Створення класу Point
#     '''Реалізація класу , Клас містить два обовязкових аргументи і поля 
#     Перше поле *.x  з одноіменим аргументом *x ,
#     Друге поле *.y з одноіменим аргументом *y '''
#     def __init__(self, some_x, some_y) -> None: 
#         '''Конструктор класу , вньому описуємо/ралізуємо обовязкові власні поля і значення які вони мають набути'''

#         self.x = some_x # Опис/реалізація поля *.x для екзеплярів цього класу .*class Point , 
#                    # При створені екземпляр , набуває значення передане як перший обовязковий аргумент *some_x # Шаблон екзепляру Point(*x, *y) 
#         self.y = some_y # Опис/реалізація поля *.y для екзеплярів цього класу .*class Point , 
#                    # При створені екземпляр , набуває значення передане як другий обовязковий аргумент *some_y# Шаблон екзепляру Point(*x, *y)
        


# # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

# point = Point(5, 10) # Стверення  екзепляру *point клас *class Point, з заданими початковими даними полів  *x і *y цього класу .
# point_1 = Point(5, 10) # Стверення  екзепляру *point_1 клас *class Point, з заданими початковими даними полів  *x і *y цього класу .
# some_name = Point("Стрічка", "Нічого собі .)") # і це також .), стверення  екзепляру *some_name клас *class Point, з заданими початковими даними полів  *x і *y цього класу .

# print(point)    # Ствоерений екзкпляр має вигляд *<__main__.Point object at 0x000001F8F57FA8D0>
# print(point.x)  # 5   # конкретне значення в полі *x цього екзкпляру.
# print(point.y)  # 10  # конкретне значення в полі *y цього екзкпляру.
# point.x = 100   # встановлення нового значення поля *x цього екзкпляру. (в тілі коду , не реалізації)
# print(point.x) # 100 # Принтим поле *x, перевіряємо чи змінилось значення. 
# print(point.y) # 10  # Принтим поле *y, перевіряємо чи змінилось значення.(поки поле *y не міняли тому значення є те що пристворенні екзепляру) 
# point.y = -45   # встановлення нового значення поля *y цього екзкпляру. 
# print(point.y) # -45 # Принтим поле *y, перевіряємо чи змінилось значення.( поле *y змінило своє початкове значення.)
# # ==============================
# print(point_1)    # Ствоерений екзкпляр має вигляд *<__main__.Point object at 0x000002AD371EA9C0>
# print(point_1.x)  # 50
# print(point_1.y)  # -10

# # =================================
# print(some_name)   # Ствоерений екзкпляр має вигляд *<__main__.Point object at 0x0000024B63ADA990>
# print(some_name.x) # Стрічка
# print(some_name.y) # Нічого собі .)


# ================================ Звдання 2 / Task 2 ======================================

# ================================  Прихвані поля , декоратори класів (@property, @імя_поля.setter) ==========================

# У Python неможливо інкапсулювати (зробити недоступними) атрибути класу. 
# Ви завжди можете отримати доступ до будь-якого атрибуту. Щоб якось вказати розробнику, 
# що доступ до атрибуту безпосередньо небажаний, прийнято називати такі поля чи методи, 
# починаючи з одного нижнього підкреслення. Якщо ж назвати атрибут так, що спочатку буде два нижні підкреслення, 
# то включиться механізм "приховання" імен. Це не означає, що доступ до цього поля буде закрито, просто небагато ускладнений.

# class Secret:
#     public_field = 'this is public'
#     _private_field = 'avoid using this please'
#     __real_secret = 'I am hidden'


# s = Secret()
# print(s.public_field)  # this is public
# print(s._private_field)  # avoid using this please
# print(s._Secret__real_secret)  # I am hidden
# Як видно з цього прикладу, доступу за допомогою s.__real_secret ні, 
# але можна отримати доступ до цього ж поля через s._Secret__real_secret, що загалом нічого не захищає.

# Цей механізм можна використовувати для реалізації механізму setter та getter. 
# Буває, виникає необхідність перевірити, що користувач хоче записати в поле. 
# Для цього можна написати окремий метод, який буде перед збереженням значення в полі реалізовувати перевірку, 
# але саме поле, як і раніше, залишиться доступним. Можна ж скористатися декоратором setter. 
# Для обчислення значення "на льоту" або як пару для setter можна скористатися декоратором property, 
# який перетворює будь-який метод на поле. Наприклад, ми хочемо перевірити, що користувач вводить лише додатні числа.

# class PositiveNumber:
#     def __init__(self):
#         self.__value = None

#     @property
#     def value(self):
#         return self.__value

#     @value.setter
#     def value(self, new_value):
#         if new_value > 0:
#             self.__value = new_value
#         else:
#             print('Only numbers greater zero accepted')

# ++++++++++++++++++++++++++++++++++++++  Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# У класу Point через конструктор __init__ оголошено два атрибути: координати x та y. 
# Приховати доступ до них з допомогою подвійного підкреслення: __x та __y

# Реалізуйте для класу Point механізми setter та getter до атрибутів __x та __y за допомогою декораторів property та setter.

# Приклад:

# point = Point(5, 10)

# print(point.x)  # 5
# print(point.y)  # 10


# +++++++++++++++++++++++++++++++++++++   Код / Code ++++++++++++++++++++++++++++++++++++

# class Point:
#     def __init__(self, x, y):
#         self.__x = x
#         self.__y = y

#     @property # Вбудований декоратор класів. Утворює з будьякого методу до якого застосовано одноімене поле класу
#               # В нашому випадку, створить поле класу з іменем *x
#     def x(self):
#         ''' Метод без аргументів , повертає значення прихованого поля *__x , 
#         Така конструкція : Декоратор *@property і метод *x() дозволяє створити екзепляр класу , з можливістю
#          опрацювання даних переданих в поле ще до створення самого екзепляру.
#         Примітка: завдання просто застосувати самі декоратори без якогосось додаткового змісту і користі'''
#         return self.__x
   
    
#     @x.setter #'''Вбудований декоратор *@x.setter для методу/поля  *x. # повертає значення декоратору *@property
#     def x(self, new_x): 
#         '''Метод приймає один обовязковий аргументи.
#           і повертає його відповідному полю екзепляру класу
#         Примітка: завдання просто застосувати самі декоратори без якогосось додаткового змісту і користі'''
        
#         self.__x = new_x # Якщо додатнє присвоюємо його прихованій змінні/полю *self.__x
    
#     @property # Вбудований декоратор класів. Утворює з будьякого методу до якого застосовано одноімене поле класу
#               # В нашому випадку, створить поле класу з іменем *y
#     def y(self):
#         ''' Метод без аргументів , повертає значення прихованого поля  *__y 
#         Така конструкція : Декоратор *@property і метод *y() дозволяє створити екзепляр класу , з можливістю
#          опрацювання даних переданих в поле ще до створення самого екзепляру.
#         Примітка: завдання просто застосувати самі декоратори без якогосось додаткового змісту і користі'''
           
#         return self.__y
       
#     @y.setter # Вбудований декоратор *@y.setter для методу/поля  *y. # повертає значення декоратору *@property
#     def y(self, new_y): 
#         '''Метод приймає один обовязковий аргументи.
#           і повертає його відповідному полю екзепляру класу
#         Примітка: завдання просто застосувати самі декоратори без якогосось додаткового змісту і користі'''
#         self.__y = new_y # присвоюємо  прихованій змінні/полю *self.__y значення *new_y, 
#                          # в нашому випадку друге значення в круглих дужках для Шаблону екзепляру *Point(x, y) .
        

# # # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

# point = Point(5, 10)

# print(point.x)  # 5
# print(point.y)  # 10

# ================================ Звдання 3 / Task 3 ======================================

# ================================  Прихвані поля , декоратори класів (@property, @імя_поля.setter) ==========================


# Розглянемо таку ситуацію. У нас є клас Person, який має властивість name

# class Person:
#     def __init__(self, name):
#         self.__name = name

#     @property
#     def name(self):
#         return self.__name

#     @name.setter
#     def name(self, name):
#         if (type(name) == str) and (len(name) > 0):
#             self.__name = name


# person = Person(123)
# print(person.name)  # 123
# У цьому коді може виникнути помилка. В setter ми робимо перевірку, 
# щоб значення було рядком та чекаємо тільки рядок ненульової довжини. 
# Але при ініціалізації значення в конструкторі, 
# коли привласнюємо self.__name=name ми насправді ігноруємо роботу setter та привласнюємо значення безпосередньо. 
# Що і сталося в нашому коді — властивість __name містить числове значення.

# Щоб цього не відбувалося, код треба переписати так:

# class Person:
#     def __init__(self, name):
#         self.__name = None
#         self.name = name

#     @property
#     def name(self):
#         return self.__name

#     @name.setter
#     def name(self, name):
#         if (type(name) == str) and (len(name) > 0):
#             self.__name = name


# person = Person(123)
# print(person.name)  # None
# Зараз у конструкторі ми привласнюємо полю __name значення None: self.__name=None.
# У другому рядку конструктора ми примусово викликаємо setter інструкцією self.name=name. 
# У такому разі setter виконується і не дозволяє нам привласнити полю __name 
# не валідне значення 123 при створенні екземпляра класу person = Person(123).

# ++++++++++++++++++++++++++++++++++++++  Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# У класу Point до механізму setter властивостей x і y додайте перевірку на значення, що вводиться. 
# Дозвольте встановлювати значення властивостей x та y для екземпляра класу, 
# тільки якщо вони мають числове значення (int або float).

# Приклад:

# point = Point("a", 10)

# print(point.x)  # None
# print(point.y)  # 10


# +++++++++++++++++++++++++++++++++++++   Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Завдання схоже на завдання 2 . Читай про приховані поля , декоратори  @property і @імя.setter в 2 завдані.
            # Відміність в тому що в конструкторі ми передаємо два аргументи *x, *y .
            # і щоб їх значення встановилось в екзепляр(якщо вони пройдуть перевірку @property і @імя.setter ) потрібно їх явно оголосити в конструкорі.
            # *self.x = x , *self.y = y - явно оголошення полів і їх значень в конструкторі.
            # Є умова що дані мають бути типу *int , *float
class Point:
    def __init__(self, x, y): # Конструктор, приймає два аргументи які будуть передані екзепляру після перевірки значень на віповідність умові.
        self.__x = None # Приховане значення поля *х , Початкове знчення *None, 
                        # Присвоється екзепляру якщо значення передані цьому полю не пройдуть перевірку *@property і *@імя.setter
        self.__y = None # Приховане значення поля *y , Початкове знчення *None, 
                        # Присвоється екзепляру якщо значення передані цьому полю не пройдуть перевірку *@property і *@імя.setter
        self.x = x # Реалізація явного поля *x, буда встановленне відповідна значення з аргумента *x , якщо пройде перевірку *@property і *@імя.setter 
        self.y = y # # Реалізація явного поля *y, буда встановленне відповідна значення з аргумента *y , якщо пройде перевірку *@property і *@імя.setter

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, new_x):
       
        if type(new_x) == int or type(new_x) == float: # Перевіряємо чи передані дані в поле *x типу *int або *float

            # isinstance(y,int) or isinstance(y, float) - такий запис не проходить атвтоперевірку 
            # Примітка від ментора : Автоперевірка перевіряє ваш код з багатьма значеннями. І тут є проблема з isinstance.
            # Оскільки він повертає True не тільки для типів, а ще і для типів, які наслідуються від типу.
            # Оскільки bool наслідується від int, то isinstance(True,  int) буде True. 
            # Більш детально ви можете прочитати ввівши help(True) у інтерпретаторі.
            # А щоб уникнути цю помилку, потрібно скористатися функцією type, яка буде повертати конкретні типи:
            # if type(new_x) == int
            self.__x = new_x
        else:
            self.__x
        
            

    @property
    def y(self):
        return self.__y

    @y.setter
    def y(self, new_y):
        
        if type(new_y) == int or type(new_y) == float :  # Перевіряємо чи передані дані в поле *y типу *int або *float

            # isinstance(y,int) or isinstance(y, float) - такий запис не проходить атвтоперевірку 
            # Примітка від ментора : Автоперевірка перевіряє ваш код з багатьма значеннями. І тут є проблема з isinstance.
            # Оскільки він повертає True не тільки для типів, а ще і для типів, які наслідуються від типу.
            # Оскільки bool наслідується від int, то isinstance(True,  int) буде True. 
            # Більш детально ви можете прочитати ввівши help(True) у інтерпретаторі.
            # А щоб уникнути цю помилку, потрібно скористатися функцією type, яка буде повертати конкретні типи:
            # if type(new_x) == int
            
            self.__y = new_y
        else:
            self.__y



# # # +++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

point = Point("a", 10)

print(point.x)  # None
print(point.y)  # 10