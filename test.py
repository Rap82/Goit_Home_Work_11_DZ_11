# class A:
#     def __init__(self, count) -> None:
#         self.count = count
#     def __eq__(self, other): # Магічний метод який дозволяє порівнювати обєкти одного класу .
#         return isinstance(other, A) and self.count == other.count
# a = A("aaa")
# b = A("bbb")
# c = A("ccc")
# my_list = [ a, b, c, ] # Список Обєктів class A
# print(f"список обэктів my_list = {my_list}")
# str_input = input("Введіть якесь значення \n # aaa, bbb, ccc\n") # Звичайний input повертає *str
# # (Для правильного результату вводим тестові значення ааа або bbb або ccc )
# str_input = A(str_input) # Приведення до типу class A
# if str_input in my_list:  # Пошук обєкту *str_input class A, в списку *my_list обєктів
#     print(f"Є таке значення в списку my_list = {my_list}" )
# else :
#     print(f"Немає такого значення в списку my_list = {my_list}" ) 


# ++++++++++++++++++++++  Трішки принтів для розуміння що можна робити з полями і даними в классі ++++++++++++++++++++++++

# class SomeClass: # Створення "якогось" класу 
#     ''' Реалізація якогось класу ). На очний приклад як можна експерементувати з полями класу і аргументом який в нього надходить'''
   
#     somestatic = "Статичне_поле *somestatic"
	
#     def __init__(self, some_argument): # Конструктор класу який приймає "якийсь" один обовязковий аргумент.
#         self.number = some_argument
#         self.dubell_number = 2*some_argument
#         self.change_number = 2*self.dubell_number + self.number 
#         self.str_number = str(some_argument)+"ff"
#         self.str_number_repit_str_number = self.str_number
        


# some = SomeClass(10) # Створення конкретного екзепляру з іменем *some, *class SomeClass з початковим значенням  10
#                      # Оскільки в констуркторі __init__ класу в нас після self , якийсь аргумент *some_argument, 
#                      # то при створені екзепляру класу ми в круглих душках обовязково маємо передати якесь значення 
# print(some.number)
# some.number = 12
# print(some.number)
# print(some.dubell_number)
# print(some.change_number)
# some.number = some.number + 5
# print(some.number)
# print(some.str_number)
# print(some.str_number_repit_str_number)
# print(some.somestatic)


####++++++++++++++++++++++++++++++++ Декоратори  @property, @*імя.setter  +++++++++++++++++++++++++++++

class PositiveNumber: # Створення класу *PositiveNumber 
    ''' Клас "Додатні числа" , має одне приховане поле в конструкторі *__value з значенням по замовчуванню *None
     Також має одне не очевидне , не приховане поле *value, утворене спеціальним декоратором *@property який з імені функції/методу,
     до якого застосовується декоратор, утворює автоматично поле класу з одноєменим іменем , 
     Щоб з цим полем можна було працювати , як з звичайним полем класу в тілі коду, 
     потрібно застосувати додатковий декоратор *@<імя_поля_з_@property>.setter(self, *якийсь_аргумент_записаний_в_поле).
     Декоратори *@property, *@імя.setter потрібні для опрацювання вхідних даних на коректність ще до того як будуть записані в екзепляр класу
     Це дозволяє уникнути в коді додаткових перевірок на некоректність даних, 
     оскільки екзепляр з некоректними даними буде створений з даними які вказані по замовчуванню в прихованому полі( звісно якщо не застосувати методи обходу) .'''
    
    def __init__(self):  
        
        '''Конструктор створює одне приховане поле *__value і значенням по замовчуванню *None.
         
         Примітка : якщо в реалізації класу, перед іменем поля чи методу, стоїть одне нижнє підкреслення, 
         то це приховане поле яке вказує іншим програмістам що значання в цьому полі містять якусь свою особливість, 
         скажімо те що безпосереднь вводиться користувачем в відповідному полі, але не попаде в екзепляр бо не пройде перевіку *@property, *@імя.setter
         або щось інше (що схочете це і реалуєте) Воно доступне зовні в тілі коду як і звичайне поле , 
         Зертаєтесь до цього поля по його умовно прихованому імені *._<імя_прихованого поля>. 
         Шаблон екзепляру : *імя_екзепляру._<імя_прихованого поля> 
         Якщо ж імя поля містить два нижніх підкреслення підряд на початку.То це поле реально не доступне і не видиме зовні в тілі коду
         Про те є особлива конструкція яка дозволяє і його за потреби змінювати. 
         Особлива конструкція шаблон : *імя_екзепляру._*ІмяКласу__*імяприхованогополя. 
         *Дивись теорію або в інтернеті.'''
        self.__value = None # Прихованому полю *.__value присвоїти значення *None(значення по замовчуванню)
                            # Якщо дані , записані в полі, не пройдеть перевірку на коректність , 
                            # то екзепляр буде створений з цим значеням по замочуванню.(значення по замовчуванню можна встановити будь яке)

    @property # Вбудований декоратор класів. Утворює з будьякого методу до якого застосовано одноімене поле класу
              # В нашому випадку, створить поле класу з іменем *value
    def value(self):
        ''' Метод без аргументів , повертає значення прихованого поля *__value
        Така конструкція : Декоратор *@property і метод value() дозволяє створити екзепляр класу з значенням по замовчуванню *None , 
         в полі *value.  '''
        return self.__value

    @value.setter #'''Вбудований декоратор *@value.setter для методу/поля  *value. # повертає значення декоратору *@property
    def value(self, new_value): 
        '''Метод приймає один обовязковий аргумент.
          Перевіряє його на коректність введення даних, на льоту, ще до створення екзепляру класу.
            # Якщо дані відповідають умові то записує їх в приховане поле *__value, а вже метод/поле *value(self)
            # повертає їх екзепляру класу . Якщо не проходять, виводить принт про помилку. Тоді метод/поле *value(self)
            # Поверне значення *__value позамовчуванню .В нашому випадку *None'''
        
        if new_value > 0:  # Умова чи значення більше 0 (додатнє)
            self.__value = new_value # Якщо додатнє присвоюємо його прихованій змінні/полю *self.__value 
        else:
            print('Only numbers greater zero accepted') # Якщо не додатнє принтим повідомлення про помилку.


p = PositiveNumber()
p.value = int(input("ВВедіть додатнє число"))
print(p.value)  # 1

p._PositiveNumber__value = -1 # Реалізація доступу до прихованого поля класу. Прихованому полю *__value присвоюємо відємне значення, напряму, з тіла коду в обхід умовам реалізованим в описі класу.
print(p.value)  # -1